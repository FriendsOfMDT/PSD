# Run-TaskSequence.ps1
# This script orchestrates the execution of a sequence of PowerShell scripts
# designed for system setup and configuration tasks.
#
# It requires Administrator privileges to run, as many of the sub-scripts
# perform actions that need elevation (e.g., registry modification, driver installation).

# --- Administrator Privileges Check ---
Write-Host "---------------------------------------------------------------------"
Write-Host "Checking for Administrator privileges..."
if (-not ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
    Write-Error "Administrator privileges are required to run this task sequence. Please re-run this script as Administrator."
    Write-Host "Script will exit in 5 seconds."
    Start-Sleep -Seconds 5
    exit 1
}
Write-Host "Administrator privileges confirmed."
Write-Host "---------------------------------------------------------------------"


# --- Define the sequence of scripts to execute ---
# Ensure these script files are located in the same directory as this main script.
$scriptsToExecute = @(
    "Hide-DOAdmin.ps1",
    "Install-Applications.ps1",
    "Enable-TipbandVisibility.ps1",
    "Set-ChromeAsDefault.ps1",
    "Install-Drivers.ps1",
    "Copy-DOTempFolder.ps1"
)

# Get the directory where this script is located. Sub-scripts are expected to be here.
$basePath = $PSScriptRoot

Write-Host "Starting Task Sequence..."
Write-Host "Base path for scripts: $basePath"
Write-Host "---------------------------------------------------------------------"

$totalScripts = $scriptsToExecute.Count
$successCount = 0
$failureCount = 0
$skippedCount = 0

# --- Loop through and execute each script ---
for ($i = 0; $i -lt $totalScripts; $i++) {
    $scriptName = $scriptsToExecute[$i]
    $scriptPath = Join-Path -Path $basePath -ChildPath $scriptName
    
    Write-Host ""
    Write-Host "($($i+1)/$totalScripts) Processing script: $scriptName"
    Write-Host "---------------------------------------------------------------------"

    if (-not (Test-Path $scriptPath -PathType Leaf)) {
        Write-Error "Script '$scriptName' not found at '$scriptPath'. Skipping."
        $skippedCount++
        $failureCount++ # Counting skipped as a failure for the sequence
        Write-Host "---------------------------------------------------------------------"
        continue
    }

    Write-Host "Starting execution of '$scriptName'..."
    try {
        # Execute the script.
        # Using '&' (call operator) to execute the script in the current scope/session.
        # Errors from the called script (if they are terminating) will be caught here.
        & $scriptPath -ErrorAction Stop # Ensure terminating errors are caught

        # Note: $LASTEXITCODE is generally for external executables.
        # For .ps1 scripts, success is usually determined by the absence of terminating errors.
        # If a sub-script uses "exit $number", that $LASTEXITCODE might be available,
        # but standard PowerShell error handling relies on try/catch for terminating errors.
        
        # Check if the script produced any non-terminating errors that were written to the error stream
        # This is a basic check. More sophisticated check might involve inspecting $Error variable count before/after.
        if ($Error.Count -gt 0 -and $Error[0].TargetObject -match $scriptName) {
             Write-Warning "Script '$scriptName' completed, but may have produced non-terminating errors. Review logs from the script itself."
             # Depending on policy, you might consider this a partial success or flag for review.
        }

        Write-Host "Successfully completed execution of '$scriptName'."
        $successCount++
    }
    catch {
        Write-Error "An error occurred during the execution of script '$scriptName'."
        Write-Error "Error details: $($_.Exception.Message)"
        # If the script itself wrote an error, that might be more specific.
        # This catches exceptions from the execution of the script itself (e.g., if it couldn't be parsed or a terminating error occurred).
        $failureCount++
    }
    finally {
        Write-Host "Finished processing '$scriptName'."
        Write-Host "---------------------------------------------------------------------"
        # Clear errors that might have been generated by the executed script to avoid confusion with the next one.
        # This is a simple clear; more complex scenarios might involve scoping $Error.
        $Error.Clear() 
    }
}

# --- Task Sequence Summary ---
Write-Host ""
Write-Host "====================================================================="
Write-Host "Task Sequence Completed."
Write-Host "Summary:"
Write-Host " - Total scripts in sequence: $totalScripts"
Write-Host " - Successfully executed: $successCount"
Write-Host " - Failed to execute (or error during execution): $failureCount"
Write-Host " - Skipped (not found): $skippedCount"
Write-Host "====================================================================="

if ($failureCount -gt 0 -or $skippedCount -gt 0) {
    Write-Warning "One or more scripts in the sequence reported errors or were skipped. Please review the logs above."
} else {
    Write-Host "All scripts in the sequence executed successfully."
}

# End of script
# Consider adding a pause if run by double-clicking, so the window doesn't close immediately.
# Read-Host -Prompt "Press Enter to exit"
